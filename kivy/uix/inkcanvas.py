from kivy.properties import OptionProperty, ListProperty
from kivy.graphics import Color, Line, SmoothLine
from math import sqrt


class StrokePoint(object):
    '''
    Point
    ===================

    This class identifies a point with 2D coordinates x and y::

        # Create a Point
        pointA = Point(2,3)
        pointB = Point(4,5)
        distance = pointA.distance_to(pointB)
    '''

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        '''Override default Equals behaviour'''
        if isinstance(other, self.__class__):
            return (self.x == other.x and self.y == other.y)
        return False

    def __ne__(self, other):
        '''Define a non equality test'''
        return not self.__eq__(other)

    def __add__(self, p):
        '''Sum two points'''
        return StrokePoint(self.x + p.x, self.y + p.y)

    def __sub__(self, p):
        '''Substract two points'''
        return StrokePoint(self.x - p.x, self.y - p.y)

    def __mul__(self, scalar):
        '''Multiply a point to a scalar'''
        return StrokePoint(self.x * scalar, self.y * scalar)

    def __div__(self, scalar):
        '''Divide a point to a scalar'''
        return StrokePoint(self.x / scalar, self.y / scalar)

    def __str__(self):
        '''String representation'''
        return "(%s, %s)" % (self.x, self.y)

    def __repr__(self):
        '''print Point'''
        return "%s(%r, %r)" % (self.__class__.__name__, self.x, self.y)

    def clone(self):
        '''Return a copy of this point'''
        return StrokePoint(self.x, self.y)

    def distance_to(self, p):
        '''Calculate euclidean distance between two points.'''
        return sqrt(pow(self.x - p.x, 2.0) + pow(self.y - p.y, 2.0))

    def to_int(self):
        '''Make the point coordinates integers'''
        return StrokePoint(int(self.x), int(self.y))

    def to_float(self):
        '''Make the point coordinates float'''
        return StrokePoint(float(self.x), float(self.y))


class StrokeRect(object):
    '''
    Rect
    ===================

    A rectangle implementation for getting bounds of objects::

        # Create a StrokeRect
        pointA = Point(2,3)
        pointB = Point(4,5)
        rect = StrokeRect(pointA, pointB)

    :Parameters:
        `p1`: StrokePoint
            Top left point of the rect.
        `p2`: StrokePoint
            Bottom right point of the rect.
    '''

    def __init__(self, p1, p2):
        self.pt1 = p1.to_float()
        self.pt2 = p2.to_float()
        self.left = min(self.pt1.x, self.pt2.x)
        self.top = max(self.pt1.y, self.pt2.y)
        self.right = max(self.pt1.x, self.pt2.x)
        self.bottom = min(self.pt1.y, self.pt2.y)
        self.width = self.right - self.left
        self.height = self.top - self.bottom

    def contains(self, p):
        ''' Returns whether or not a stroke_point is inside the rectangle '''
        return (self.left <= p.x <= self.right and
                self.top <= p.y <= self.bottom)

    def overlaps(self, rect):
        ''' Returns whether or not two strokerects overlap '''
        return (self.right > rect.left and self.left < rect.right and
                self.top < rect.bottom and self.bottom > rect.top)

    def top_left(self):
        '''Get the top-left corner stroke_point'''
        return StrokePoint(self.left, self.top)

    def bottom_right(self):
        '''Get the bottom right corner stroke_point'''
        return StrokePoint(self.right, self.bottom)

    def __str__(self):
        return "<Rect (%s,%s) - (%s,%s)>" % (self.left, self.top,
                                             self.right, self.bottom)

    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__,
                               StrokePoint(self.left, self.top),
                               StrokePoint(self.right, self.bottom))


class Stroke(object):
    '''
    Stroke
    ===================

    This class allows you to easily manipulate points on
    an InkCanvas, handles some basic drawing attributes and
    methods to filter and sample the original points list::

        # Create a Stroke and modify attributes
        stroke = Stroke(group_id=g)
        stroke.color = Stroke.Color.Yellow
        stroke.isHighlighter(0.5)
        stroke.points.append(StrokePoint(8.0, 9.0))

    .. warning::

        You won't really instantiate Strokes: it's more an example how
        InkCanvas handle strokes. Typically, you would use the list of strokes
        generated by InkCanvas for further processing.

    '''

    def __init__(self, group_id="", shortstraw_const=40.0):
        self.points = []
        self.color = self.Color.Black
        self.group_id = group_id
        self.sampled_points = []
        self.shortstraw_const = shortstraw_const

    def __eq__(self, other):
        '''Override default Equals behaviour'''
        if isinstance(other, self.__class__):
            return self.__dict__ == other.__dict__
        return False

    def __ne__(self, other):
        '''Define a non equality test'''
        return not self.__eq__(other)

    def __str__(self):
        '''String representation'''
        cad = "["
        for point in self.points:
            cad += "(%s, %s)," % (point.x, point.y)
        return cad[:-1] + "]"

    def __repr__(self):
        '''print StrokePoint'''
        cad = "<%s> [" % (self.__class__.__name__)
        for point in self.points:
            cad += "(%r, %r)," % (point.x, point.y)
        return cad[:-1] + "]"

    def is_highlighter(self, alfa):
        '''Change the alpha value in Color, for transparency'''
        if(len(self.color) == 4):
            self.color = (self.color[0], self.color[1], self.color[2])
        self.color = self.color + (alfa,)

    def visibility(self, visible):
        '''Defines whether or not a stroke is visible'''
        alfa = 1
        if len(self.color) == 4:
            alfa = self.color[3]
            self.color = (self.color[0], self.color[1], self.color[2])
        if not visible:
            self.color = self.color + (0,)
        else:
            self.color = self.color + (alfa,)

    def hit_test(self, p):
        '''Allows to know if a point is close to any of the strokes on canvas'''
        for point in self.points:
            dist = point.distance_to(p)
            if dist < 5.0:
                return True
        return False

    def get_bounds(self):
        '''Returns a StrokeRect which is a logical rectangle with
        the bounds of a stroke expressed as top, left, bottom, right
        values.
        :Returns:
            Stroke bounds as a StrokeRect. It is a
            :class:`~kivy.uix.inkcanvas.StrokeRect`
        '''
        minx = float("inf")
        maxx = float(0)
        miny = float("inf")
        maxy = float(0)
        for point in self.points:
            if point.x < minx:
                minx = point.x
            if point.x > maxx:
                maxx = point.x
            if point.y < miny:
                miny = point.y
            if point.y > maxy:
                maxy = point.y
        return StrokeRect(StrokePoint(minx, maxy), StrokePoint(maxx, miny))

    def filtering(self):
        '''Returns a copy of the points list with points that are not in
        a 2.0 radius from the original point. Distance is calculate by
        euclidean distance.
        ::
            >>> filtered_points = self.filtering()
            >>> self.points
            (22,10), (22,11), (25,15), (26,15), (30,11)
            >>> filtered_points
            (22, 10), (25,15), (30,11)
        .. versionadded:: 1.9.0
        '''
        clone_points = self.points[:]
        for i, point in enumerate(clone_points):
            if i > 0:
                d = clone_points[i - 1].distance_to(clone_points[i])
                if d <= 2.0:
                    clone_points.remove(point)
        return clone_points

    def sample_points(self):
        '''Stores a copy of the points list in self.sampled_points that
        were processed and their positions recalculated to be at the same
        euclidean distance.
        ::
            >>> self.sample_points()
            >>> self.points
            PointA, PointB, PointC, PointD, PointE
            >>> self.sampled_points
            PointA.distance_to(PointB) = PointB.distance_to(PointC) =
                    PointC.distance_to(PointD)
        .. versionadded:: 1.9.0
        '''
        bounds = self.get_bounds()
        S = bounds.top_left().distance_to(bounds.bottom_right()) / \
                             self.shortstraw_const
        D = 0.0
        self.sampled_points.append(self.points[0])
        clone_points = self.points[:]
        for i, point in enumerate(clone_points):
            if i > 0:
                d = clone_points[i - 1].distance_to(clone_points[i])
                if (D + d) >= S:
                    q = StrokePoint(-1, -1)
                    q.x = clone_points[i - 1].x + ((S - D) / d) * \
                                (clone_points[i].x - clone_points[i - 1].x)
                    q.y = clone_points[i - 1].y + ((S - D) / d) * \
                                (clone_points[i].y - clone_points[i - 1].y)
                    self.sampled_points.append(q)
                    clone_points.insert(i, q)
                    D = 0.0
                else:
                    D = D + d

    def get_graphics_line_points(self):
        '''Points in vertex instructions format for rendering'''
        linepoints = []
        for point in self.sampled_points:
            linepoints.extend([float(point.x), float(point.y)])
        return linepoints

    class Color(object):
        '''Values for different colors so a Stroke can
        change its color by name, rather than a tuple
        '''
        AliceBlue = (0.941176, 0.972549, 1)
        AntiqueWhite = (0.980392, 0.921569, 0.843137)
        AquaMarine = (0.498039, 1, 0.831373)
        Azure = (0.941176, 1, 1)
        Beige = (0.960784, 0.960784, 0.862745)
        Black = (0, 0, 0)
        BlanchedAlmond = (1, 0.921569, 0.803922)
        Blue = (0, 0, 1)
        BlueViolet = (0.541176, 0.168627, 0.886275)
        Brown = (0.647059, 0.164706, 0.164706)
        BurlyWood = (0.870588, 0.721569, 0.529412)
        CadetBlue = (0.372549, 0.619608, 0.627451)
        ChartReuse = (0.498039, 1, 0)
        Chocolate = (0.823529, 0.411765, 0.117647)
        Coral = (1, 0.498039, 0.313725)
        CornFlowerBlue = (0.392157, 0.584314, 0.929412)
        CornSilk = (1, 0.972549, 0.862745)
        Crimson = (0.862745, 0.0784314, 0.235294)
        Cyan = (0, 1, 1)
        DarkBlue = (0, 0, 0.545098)
        DarkCyan = (0, 0.545098, 0.545098)
        DarkGoldenRod = (0.721569, 0.52549, 0.0431373)
        DarkGray = (0.662745, 0.662745, 0.662745)
        Green = (0, 1, 0)
        Grey = (0.745098, 0.745098, 0.745098)
        Indigo = (0.294118, 0, 0.509804)
        Yellow = (1, 1, 0)
        White = (1, 1, 1)


class StrokeCanvasBehavior(object):
    '''StrokeCanvas behavior.

    :Events:
        `on_stroke_added`
            Fired when a stroke is drawn in the canvas.
        `on_stroke_removed`
            Fired when a stroke is removed from the canvas.

    .. versionadded:: 1.9.0

    '''

    strokes = ListProperty([])
    mode = OptionProperty("draw", options=["draw", "erase", "touch"])
    __events__ = ('on_stroke_added', 'on_stroke_removed')

    def __init__(self, **kwargs):
        super(StrokeCanvasBehavior, self).__init__(**kwargs)

    def on_touch_down(self, touch):
        #capture touch and add group_id to stroke to associate it
        if super(StrokeCanvasBehavior, self).on_touch_down(touch):
            return True
        if self.collide_point(*touch.pos):
            touch.grab(self)
            ud = touch.ud
            ud['group'] = g = str(touch.uid)
            pt = StrokePoint(touch.x, touch.y)
            if self.mode == 'draw':
                stroke = Stroke(group_id=g)
                stroke.color = stroke.Color.DarkBlue
                stroke.is_highlighter(0.5)
                stroke.visibility(True)
                stroke.points.append(pt)
                touch.ud['stroke'] = stroke
                '''Calculate stroke_point size according to pressure'''
                #if 'pressure' in touch.profile:
                with self.canvas:
                    Color(*stroke.color)
                    touch.ud['line'] = Line(points=(pt.x, pt.y),
                                            width=2.0, group=g)
            elif self.mode == 'erase':
                self.remove_stroke(pt)

    def on_touch_move(self, touch):
        '''If pressure changed recalculate the stroke_point size'''
        if super(StrokeCanvasBehavior, self).on_touch_move(touch):
            return True
        if touch.grab_current is self:
            pt = StrokePoint(touch.x, touch.y)
            if self.mode == 'draw':
                touch.ud['stroke'].points.append(pt)
                touch.ud['line'].points += [pt.x, pt.y]
            elif self.mode == 'erase':
                self.remove_stroke(pt)

    def on_touch_up(self, touch):
        if touch.grab_current is self:
            pt = StrokePoint(touch.x, touch.y)
            if self.mode == 'draw':
                touch.ud['stroke'].points.append(pt)
                self.add_stroke(touch.ud['stroke'])
                touch.ud['stroke'].sample_points()
                points_list = touch.ud['stroke'].filtering()
                print len(touch.ud['stroke'].points)
                print len(points_list)
                with self.canvas:
                    Color(0, 0, 1)
                    Line(points=touch.ud['stroke'].get_graphics_line_points(),
                         width=1.0)
            elif self.mode == 'erase':
                pass
            touch.ungrab(self)
        else:
            return super(StrokeCanvasBehavior, self).on_touch_up(touch)

    def add_stroke(self, stroke):
        self.strokes.append(stroke)
        self.dispatch('on_stroke_added', stroke)

    def remove_stroke(self, pt):
        for stroke in self.strokes:
            if stroke.hit_test(pt):
                self.canvas.remove_group(stroke.group_id)
                self.dispatch('on_stroke_removed', stroke)
                if stroke in self.strokes:
                    self.strokes.remove(stroke)

    def on_stroke_added(self, stroke):
        pass

    def on_stroke_removed(self, stroke):
        pass
